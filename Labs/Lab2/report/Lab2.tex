\documentclass[12pt,a4paper]{article}

%----------------------------------------------------------------------------------------
% PACKAGES
%----------------------------------------------------------------------------------------
\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{fontspec}
\setmainfont{Times New Roman}

\usepackage{graphicx,float,booktabs,array,multirow,url}
\usepackage{gensymb}
\usepackage[british]{babel}
\usepackage[square,numbers,sort&compress]{natbib}
\usepackage{caption,subcaption}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}

\usepackage{minted}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\addtolength{\topmargin}{-2.5pt}

\usepackage{silence}
\WarningFilter{gensymb}{Not defining}

\usepackage[colorlinks=true,
            linkcolor=blue,
            citecolor=blue,
            urlcolor=blue]{hyperref}

%----------------------------------------------------------------------------------------
% CUSTOM ABSTRACT FORMAT
%----------------------------------------------------------------------------------------
\makeatletter
\renewenvironment{abstract}{
    \begin{center}
        \large\bfseries \abstractname
    \end{center}
    \begin{quote}\small
}{
    \end{quote}
}
\makeatother

%----------------------------------------------------------------------------------------
% USER INFORMATION
%----------------------------------------------------------------------------------------
\newcommand{\studentname}{Yuwei ZHAO}
\newcommand{\studentnumber}{23020036096}
\newcommand{\labgroup}{Group \#31}
\newcommand{\labdate}{2025-11-14}
\newcommand{\course}{Robotics Integration Group Project I}
\newcommand{\labtitle}{Lab 2 Report}

%----------------------------------------------------------------------------------------
% TITLE
%----------------------------------------------------------------------------------------
\title{
    \vspace{-1cm}
    \textbf{\labtitle}\\[0.3em]
    \Large \course
}
\author{
    \studentname~(\studentnumber)\\
    \labgroup \quad \labdate
}
\date{}

%----------------------------------------------------------------------------------------
% PAGE STYLE
%----------------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\labtitle}
\fancyhead[C]{\studentname~(\studentnumber)}
\fancyhead[R]{\labgroup}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.75em}

%----------------------------------------------------------------------------------------
% DOCUMENT BODY
%----------------------------------------------------------------------------------------
\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
\begin{abstract}
This report documents the setup and experimentation undertaken in Lab 2. 
The primary objectives are to install and configure the Robot Operating System (\textit{ROS}) environment on Ubuntu, establish a functioning Catkin workspace, and gain practical experience with core ROS communication mechanisms. 
Through a sequence of hands-on tasks, the lab introduces essential ROS concepts such as node creation, publisher-subscriber communication, topic monitoring, and system visualization using tools like {\tt rqt\_graph} and {\tt roscore}. 
The experiment provides a foundational understanding of how ROS facilitates modular, distributed robotics software development.  

See Resources on \href{https://github.com/RamessesN/Robotics_MIT}{github.com/RamessesN/Robotics\_MIT}.
\end{abstract}

%----------------------------------------------------------------------------------------
\section{Introduction}
This laboratory session focuses on the installation, configuration and initial exploration of the Robot Operating System (\textit{ROS}), which serves as the middleware framework for subsequent robotics development. 
Before implementing perception, planning or control modules, it is essential to understand the \textit{ROS} architecture and its communication mechanisms. 
The experiment involves setting up the \textit{ROS} environment, creating and managing a catkin workspace, and developing simple publisher and subscriber nodes to exchange data through topics. 

%----------------------------------------------------------------------------------------
\section{Procedure}
%----------------------------------------------------------------------------------------
\subsection{Part I}
\subsubsection{Objective}
To set up the \textit{ROS} environment on the \textit{Ubuntu 24.04} operating system, including the installation of essential packages and the configuration of a functional Catkin workspace.

\subsubsection{Methodology}
The initial approach for installing \textit{ROS Noetic} was as follows:
\begin{enumerate}
    \item Add the \textit{ROS} package sources and install \textit{ROS Noetic}:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'
curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
sudo apt update
sudo apt install ros-noetic-desktop-full
    \end{minted}

    \item Configure the \textit{ROS} environment and install additional dependencies:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc
source ~/.bashrc
sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator \
python3-vcstool build-essential python3-catkin-tools python-is-python3
    \end{minted}

    \item Initialize \textit{rosdep} to enable dependency management:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
sudo rosdep init
rosdep update
    \end{minted}
\end{enumerate}

However, the above method is not fully compatible with \textit{Ubuntu 24.04}.  
To address this, an alternative installation procedure using the \textit{Shrike} repository was adopted, which provided a successful setup.

\begin{enumerate}
    \item Clone the \href{https://github.com/Minoic-Intelligence/shrike.git}{\textit{Shrike}} repository from GitHub:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
git clone git@github.com:Minoic-Intelligence/shrike.git
    \end{minted}

    \item Follow the instructions provided in the \textit{Shrike} repository to complete the installation.  
    The resulting terminal output is shown in Figure~\ref{fig:ros_noetic_installation}.
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
./scripts/install_ubuntu24.sh
./src/catkin/bin/catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release
source ./install_isolated/setup.bash
    \end{minted}
\end{enumerate}

\subsubsection{Observations}
\begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{./source/img/partI_1.png}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.48\textwidth}
        \includegraphics[width=\textwidth]{./source/img/partI_2.png}
    \end{minipage}
    \caption{Installation of \textit{ROS Noetic} on \textit{Ubuntu 24.04}}
    \label{fig:ros_noetic_installation}
\end{figure}

\subsubsection{Discussion}
Installing \textit{ROS Noetic} on \textit{Ubuntu 24.04} presents several challenges due to incompatibilities between the standard Noetic packages and the latest system libraries.  
By utilizing the \textit{Shrike} repository—which provides customized build scripts tailored for Ubuntu 24.04—the installation process was completed successfully.  
This outcome highlights the necessity of adapting traditional installation procedures to evolving system environments and demonstrates the value of community-maintained solutions when official support is unavailable.

%----------------------------------------------------------------------------------------
\subsection{Part II}
\subsubsection{Objective}
To deepen the understanding of the \textit{ROS} communication framework by implementing publisher and subscriber nodes, exploring topic-based message exchange, and visualizing the inter-node topology. 
This experiment establishes the foundation for modular, event-driven robotic behavior through:
\begin{enumerate}
    \item Implementing \textit{ROS} nodes that publish and subscribe to custom message types.
    \item Demonstrating data flow between nodes via topics and verifying correct message delivery.
    \item Utilizing diagnostic and visualization tools (such as {\tt rqt\_graph}) to examine node–topic connectivity.
    \item Ensuring the workspace is properly configured to build, launch, and manage multiple nodes within a \textit{ROS} ecosystem.
\end{enumerate}

\subsubsection{Methodology}
\begin{itemize}
    \item \textbf{\textit{ROS} Master} \\[0.2em]
    Start the \textit{ROS} Master using the following command.  
    The resulting output is shown in Figure~\ref{fig:ros_master}.
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
roscore
    \end{minted}

    \item \textbf{\textit{ROS} Nodes}
    \begin{enumerate}
        \item Launch the \textit{turtlesim} node in a new terminal:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun turtlesim turtlesim_node
        \end{minted}

        \item List active nodes using:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosnode list
        \end{minted}

        \item Launch the \textit{turtle\_teleop\_key} node to control the turtle with keyboard input:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun turtlesim turtle_teleop_key
        \end{minted}

        \item The corresponding runtime output is illustrated in Figure~\ref{fig:ros_nodes}.
    \end{enumerate}

    \item \textbf{\textit{ROS} Topics}
    \begin{enumerate}
        \item Visualize the communication graph of running nodes and topics:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun rqt_graph rqt_graph
        \end{minted}

        \item Monitor velocity commands sent to the turtle in real time:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rostopic echo /turtle1/cmd_vel
        \end{minted}

        \item Create a simple \textit{C++} example node:
        \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{cpp}
#include <ros/ros.h>

int main(int argc, char** argv) {
    ros::init(argc, argv, "example_node");
    ros::NodeHandle n;

    ros::Rate loop_rate(50);

    while (ros::ok()) {
        ros::spinOnce();
        loop_rate.sleep();
    }
    return 0;
}
        \end{minted}

        To compile and execute this example using \textit{Shrike}, follow these steps:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
cd ~/shrike/ros_ws/src
catkin_create_pkg ros_sample roscpp std_msgs
        \end{minted}

        The resulting workspace structure is:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
- ros_ws/
  - src/
    - ros_sample/
      - CMakeLists.txt
      - include/
      - package.xml
      - src/
        - ros_sample.cpp
        \end{minted}

        Replace \textit{example\_node.cpp} with \textit{ros\_sample.cpp} and update the \textit{CMakeLists.txt} file as follows:
        \begin{minted}[fontsize=\footnotesize,breaklines,frame=single]{cpp}
cmake_minimum_required(VERSION 3.0.2)
project(ros_sample)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_msgs
)

catkin_package()

include_directories(
  ${catkin_INCLUDE_DIRS}
)

add_executable(ros_sample_node src/ros_sample.cpp)
target_link_libraries(ros_sample_node ${catkin_LIBRARIES})
        \end{minted}

        Build and source the workspace:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
cd ~/shrike/ros_ws
catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release
source ~/shrike/ros_ws/devel_isolated/setup.bash
rosrun ros_sample ros_sample_node
        \end{minted}

        Verify that the node is active using \texttt{rosnode list}.  
        The corresponding results are shown in Figure~\ref{fig:ros_topics}.

        \item \textbf{\textit{TF} Tools}
        \begin{itemize}
            \item Launch the Turtle TF demo:
            \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
roslaunch turtle_tf turtle_tf_demo.launch
            \end{minted}

            \textit{Note:} On Ubuntu 24.04 with \textit{Shrike}, older Noetic packages may depend on Python 2, while only Python 3 is installed.  
            To resolve this compatibility issue, create a symbolic link:
            \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
sudo ln -s /usr/bin/python3 /usr/bin/python
            \end{minted}

            \item Visualize the TF tree using:
            \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun rqt_tf_tree rqt_tf_tree
            \end{minted}
            The visualization shows three coordinate frames: \textit{world} (parent), \textit{turtle1}, and \textit{turtle2}.

            \item Inspect transformations in real time:
            \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun tf tf_echo /turtle1 /turtle2
            \end{minted}

            \item The resulting output is illustrated in Figure~\ref{fig:tf_tools}.
        \end{itemize}

        \item \textbf{Using \textit{RViz}} \\[0.2em]
        Run the following command to launch \textit{RViz}:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
LIBGL_ALWAYS_SOFTWARE=1 rviz
        \end{minted}
        Software rendering is required because \textit{RViz} relies on OpenGL, which may not be fully supported in virtualized environments.  
        The visualization result is shown in Figure~\ref{fig:rviz}.
    \end{enumerate}

    \textit{Notice:} Modify the \textit{view\_frames} script for Python 3.x compatibility:
    \begin{minted}[fontsize=\footnotesize,breaklines,frame=single]{python}
try:
    vstr = subprocess.Popen(args, stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT).communicate()[0]
    vstr = vstr.decode('utf-8')
except OSError as ex:
    print("Warning: Could not execute `dot -V`. Is graphviz installed?")
    sys.exit(-1)

v = distutils.version.StrictVersion('2.16')
r = re.compile(r".*version (\d+\.?\d*)")
print(vstr)
m = r.search(vstr)
    \end{minted}
\end{itemize}

\subsubsection{Observations}
\begin{itemize}
    \item \textit{ROS} Master
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{./source/img/partII_1.png}
        \caption{ROS Master}
        \label{fig:ros_master}
    \end{figure}

    \item \textit{ROS} Nodes
    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{\textwidth}
            \begin{minipage}[b]{0.35\textheight}
                \includegraphics[width=\textwidth]{./source/img/partII_2.png}
                \caption*{(a) Turtlesim node running}
            \end{minipage}
            \hfill
            \begin{minipage}[b]{0.25\textheight}
                \includegraphics[width=\textwidth]{./source/img/partII_3.png}
                \caption*{(b) rosnode list output}
            \end{minipage}
        \end{minipage}
        \vfill
        \begin{minipage}[b]{\textwidth}
            \begin{minipage}[b]{0.35\textheight}
                \includegraphics[width=\textwidth]{./source/img/partII_4.png}
                \caption*{(c) Turtle teleop node running}
            \end{minipage}
            \hfill
            \begin{minipage}[b]{0.25\textheight}
                \includegraphics[width=\textwidth]{./source/img/partII_5.png}
                \caption*{(d) rosnode list output}
            \end{minipage}
        \end{minipage}
        \caption{ROS nodes}
        \label{fig:ros_nodes}
    \end{figure}

    \item \textit{ROS} Topics
    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{\textwidth}
            \centering
            \begin{minipage}[b]{0.25\textheight}
                \centering
                \includegraphics[width=\textwidth]{./source/img/partIII_1.png}
                \caption*{(a) rqt\_graph output}
            \end{minipage}
            \hfill
            \begin{minipage}[b]{0.35\textheight}
                \centering
                \includegraphics[width=\textwidth]{./source/img/partIII_2.png}
                \caption*{(b) Velocity topic output}
            \end{minipage}
        \end{minipage}
        \vfill
        \begin{minipage}[b]{\textwidth}
            \centering
            \begin{minipage}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{./source/img/partIII_3.png}
                \caption*{(c) ROS node running}
            \end{minipage}
            \hfill
            \begin{minipage}[b]{0.48\textwidth}
                \centering
                \includegraphics[width=\textwidth]{./source/img/partIII_4.png}
                \caption*{(d) rosnode list output}
            \end{minipage}
        \end{minipage}
        \vfill
        \begin{minipage}[b]{\textwidth}
            \centering
            \includegraphics[width=0.6\textwidth]{./source/img/partIII_5.png}
            \caption*{(e) Roslaunch output}
        \end{minipage}
        \caption{ROS topics}
        \label{fig:ros_topics}
    \end{figure}

    \begin{figure}[H]
        \centering
        \begin{minipage}[b]{0.48\textwidth}
            \centering
            \includegraphics[width=\textwidth]{./source/img/partIII_6.png}
            \caption*{(a) rqt\_tf\_tree output}
        \end{minipage}
        \hfill
        \begin{minipage}[b]{0.48\textwidth}
            \centering
            \includegraphics[width=\textwidth]{./source/img/partIII_7.png}
            \caption*{(b) tf\_echo output}
        \end{minipage}
        \caption{TF tools}
        \label{fig:tf_tools}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{./source/img/partIII_8.png}
        \caption{RViz}
        \label{fig:rviz}
    \end{figure}
\end{itemize}

\subsubsection{Discussion}
This section demonstrates the core principles of inter-node communication and system visualization within the \textit{ROS} framework.  
By implementing publisher and subscriber nodes and observing message flow using \textit{rqt\_graph} and \textit{rostopic echo}, it becomes clear how topic-based communication enables modular and decoupled node interaction.  
The ability to monitor live message streams allows developers to validate correct behavior and quickly identify configuration or runtime issues.

The use of \textit{TF} frames further illustrates the importance of coordinate transformation management in robotic systems.  
The hierarchical relationship among the \textit{world}, \textit{turtle1}, and \textit{turtle2} frames highlights how spatial relationships are maintained and broadcast across the \textit{ROS} network.  
Tools such as \textit{rqt\_tf\_tree} and \textit{tf\_echo} provide intuitive means of visualizing and debugging frame hierarchies, reinforcing understanding of kinematic relationships and transformation propagation.

Running \textit{RViz} in a virtualized environment emphasizes practical considerations for deploying visualization tools.  
The need to enforce software rendering with \texttt{LIBGL\_ALWAYS\_SOFTWARE=1} underscores how hardware acceleration and OpenGL support directly affect performance and usability.

%----------------------------------------------------------------------------------------\subsection{Part III}
\subsection{Part III}
\subsubsection{Objective}
To utilize the \textit{TF} package to control the movement of drones and visualize their trajectories dynamically in \textit{RViz}.

\subsubsection{Methodology}
\begin{enumerate}
    \item \textbf{Setting up the workspace} \\
    First, create a Catkin workspace named \textit{vnav\_ws} under the home directory:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
mkdir -p ~/vnav_ws/src
cd ~/vnav_ws/
catkin init
    \end{minted}

    The output should appear as shown in Figure~\ref{fig:catkin_init_build}.  
    Next, copy the \textit{two\_drones\_pkg} package into the \textit{src} folder:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
cp -a /source_path/two_drones_pkg ~/vnav_ws/src
    \end{minted}

    Then, build the workspace using:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
catkin build
    \end{minted}

    The build output is shown in Figure~\ref{fig:catkin_init_build}.  
    After the build completes, source the setup file to refresh the environment:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
source devel/setup.bash
    \end{minted}

    Finally, launch \textit{ROS} to visualize the static drone scene in \textit{RViz}:
    \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
roslaunch two_drones_pkg two_drones.launch static:=True
    \end{minted}

    After adding the \textit{TF} display, three colored axes will appear for each coordinate frame, as illustrated in Figure~\ref{fig:two_drones_pkg}.  
    Remember to save the \textit{RViz} configuration once the setup is complete.

    \item \textbf{Basic \textit{ROS} commands}
    \begin{itemize}
        \item \textbf{Listing active nodes} \\
        The active nodes in the static scene can be verified via \textit{rqt\_graph} and the output includes:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
/frames_publisher_node
/plots_publisher_node
/rviz
        \end{minted}

        \item \textbf{Running without roslaunch} \\
        The static scene can also be launched manually using \textit{rosrun}:
        \begin{minted}[fontsize=\footnotesize,breaklines]{bash}
rosrun two_drones_pkg frames_publisher_node
rosrun two_drones_pkg plots_publisher_node
rosrun rviz rviz -d path/to/rviz_config.rviz
        \end{minted}
        
        \item \textbf{Node–topic relationships} \\
        The topic connections between nodes are summarized below:
        \begin{table}[H]
            \renewcommand{\arraystretch}{1.3}
            \begin{center}
                \begin{tabular}{l|c|c|p{8cm}}
                    \textbf{Node} & \textbf{Publishes} & \textbf{Subscribes} & \textbf{Description} \\
                    \hline
                    \textbf{frames\_publisher\_node} & /tf & N/A & Broadcasts the coordinate transformations of AV1 and AV2 \\
                    \textbf{plots\_publisher\_node} & /visuals & /tf & Generates trajectory \textit{Marker}s and calculates AV2’s position relative to AV1 \\
                    \textbf{rviz} & N/A & /visuals, /tf & Visualizes the drone grid and trajectories in 3D \\
                \end{tabular}
            \end{center}
        \end{table}

        \item \textbf{Effect of omitting \textit{static:=True}} \\
        The \textit{static} argument determines whether \textit{TF} uses a static transform broadcaster.  
        If omitted, transforms will be published dynamically at each iteration, which in dynamic scenes can increase message traffic and slightly reduce performance.
    \end{itemize}

    \item \textbf{Dynamic scene visualization} \\
    To simulate drone movement, a \texttt{TransformBroadcaster} is instantiated to periodically send transform messages:
    \begin{minted}[fontsize=\footnotesize,breaklines]{cpp}
tf2_ros::TransformBroadcaster tf_broadcaster;
    \end{minted}

    The elapsed time since startup is computed as:
    \begin{minted}[fontsize=\footnotesize,breaklines]{cpp}
double time = (ros::Time::now() - startup_time).toSec();
    \end{minted}

    Each drone has an associated \texttt{TransformStamped} message:
    \begin{minted}[fontsize=\footnotesize,breaklines,frame=single]{cpp}
geometry_msgs::TransformStamped AV1World;
geometry_msgs::TransformStamped AV2World;
AV1World.transform.rotation.w = 1.0;
AV2World.transform.rotation.w = 1.0;
    \end{minted}

    \textbf{AV1} moves along a circular path on the $xy$-plane centered at the world origin:
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{cpp}
// --- AV1 ---
AV1World.header.frame_id = "world";
AV1World.child_frame_id = "av1";
AV1World.transform.translation.x = cos(time);
AV1World.transform.translation.y = sin(time);
AV1World.transform.translation.z = 0.0;

tf2::Quaternion q1;
q1.setRPY(0, 0, time);
AV1World.transform.rotation.x = q1.x();
AV1World.transform.rotation.y = q1.y();
AV1World.transform.rotation.z = q1.z();
AV1World.transform.rotation.w = q1.w();
    \end{minted}

    \textbf{AV2} follows a sinusoidal path along the $x$–$z$ plane:
    \begin{minted}[fontsize=\footnotesize,breaklines,linenos,frame=single]{cpp}
// --- AV2 ---
AV2World.header.frame_id = "world";
AV2World.child_frame_id = "av2";
AV2World.transform.translation.x = sin(time);
AV2World.transform.translation.y = 0.0;
AV2World.transform.translation.z = cos(2 * time);
    \end{minted}

    Finally, both transforms are broadcast:
    \begin{minted}[fontsize=\footnotesize,breaklines]{cpp}
tf_broadcaster.sendTransform(AV1World);
tf_broadcaster.sendTransform(AV2World);
    \end{minted}

    The complete source code for \texttt{frames\_publisher\_node.cpp} is provided in \hyperref[section:source_code]{\texttt{Source Code}} at the end of this report.

    \item \textbf{Trajectory visualization} \\
    To visualize the drones' trajectories, \textit{TF} data is queried using \texttt{lookupTransform} to retrieve each drone’s position relative to the world frame:
    \begin{itemize}
        \item \textit{tf\_buffer} stores transformation history between coordinate frames.
        \item \textit{lookupTransform(ref\_frame, dest\_frame, ros::Time(0))} retrieves the latest pose.
        \item \textit{ros::Duration(0.1)} ensures synchronization by waiting briefly if needed.
    \end{itemize}

    Besides, with \textit{Duration(0.1)} exists but there is no other thread to process the messages from \textit{TF}.
    Therefore, the transform buffer will never be updated unless a dedicated thread or asynchronous spinner is created to handle incoming \textit{TF} messages. 
    In \textit{tf2\_ros}, this can be achieved by enabling the internal thread of the \textit{TransformListener}, which continuously listens to the TF topic and updates the buffer in the background, as shown below:
    \begin{minted}[fontsize=\footnotesize,breaklines]{cpp}
tf2_ros::Buffer tf_buffer{ros::Duration(10.0), true};
tf2_ros::TransformListener tf_listener{tf_buffer};
    \end{minted}

    Here, the second parameter \texttt{true} tells the listener to spawn a dedicated thread to process incoming TF data asynchronously. 
    Without this background thread, the buffer would remain empty, and any subsequent calls to 
    \texttt{lookupTransform()} would fail with a time extrapolation or "transform not found" error.

    These steps ensure that \textit{RViz} dynamically updates both trajectories in real time.  
    The resulting visualization is shown in Figure~\ref{fig:drones_path}.
\end{enumerate}

\subsubsection{Observations}
\begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./source/img/partIV_1.png}
        \caption*{(a) catkin init}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{./source/img/partIV_2.png}
        \caption*{(b) catkin build}
    \end{minipage}
    \caption{Catkin workspace initialization and build}
    \label{fig:catkin_init_build}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{./source/img/partIV_3.png}
    \caption{Static visualization of two drones in \textit{RViz}}
    \label{fig:two_drones_pkg}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{./source/img/partIV_4.png}
    \caption{Dynamic trajectories of two drones in \textit{RViz}}
    \label{fig:drones_path}
\end{figure}

\subsubsection{Discussion}
This session successfully demonstrates how \textit{TF} enables both static and dynamic spatial relationships to be visualized in real time.  
In the \textbf{static} case, each transform is broadcast only once, minimizing system overhead. 
In contrast, \textbf{dynamic} broadcasting continuously updates transforms according to the elapsed time, allowing for smooth motion visualization but at a higher computational and communication cost.

The design of the two distinct motion models—circular motion for AV1 and sinusoidal motion for AV2—illustrates the flexibility of \textit{TF} in representing diverse kinematic behaviors. 
By combining \textit{tf2\_ros::TransformBroadcaster} with \textit{lookupTransform}, the system maintains synchronization between frames and ensures that \textit{RViz} accurately reflects the relative positions and orientations of both drones.

%----------------------------------------------------------------------------------------
\section{Reflection and Analysis}
% TODO: Write a reflection and analysis of the lab report.

%----------------------------------------------------------------------------------------
\section{Conclusion}
% TODO: Write the conclusion of the lab report.
\newpage

%----------------------------------------------------------------------------------------
% Source Code
%----------------------------------------------------------------------------------------
\pagestyle{empty}
\section{Source Code}
\label{section:source_code}
\begin{itemize}
    \item \textit{frames\_publisher\_node.cpp}
    \begin{minted}[fontsize=\footnotesize,frame=single,linenos,breaklines]{cpp}
#include <ros/ros.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2/LinearMath/Quaternion.h>

#include <iostream>

class FramesPublisherNode {
    private:
    ros::NodeHandle nh;
    ros::Time startup_time;

    ros::Timer heartbeat;

    tf2_ros::TransformBroadcaster tf_broadcaster;

    public:
    FramesPublisherNode() {
        // NOTE: This method is run once, when the node is launched.
        startup_time = ros::Time::now();
        heartbeat = nh.createTimer(ros::Duration(0.02), &FramesPublisherNode::onPublish, this);
        heartbeat.start();
    }

    void onPublish(const ros::TimerEvent&) {
        double time = (ros::Time::now() - startup_time).toSec();

        geometry_msgs::TransformStamped AV1World;
        geometry_msgs::TransformStamped AV2World;

        AV1World.transform.rotation.w = 1.0;
        AV2World.transform.rotation.w = 1.0;

        // --- AV1 ---
        AV1World.header.stamp = ros::Time::now();
        AV1World.header.frame_id = "world";
        AV1World.child_frame_id = "av1";
        // path: [cos(t), sin(t), 0]
        AV1World.transform.translation.x = cos(time);
        AV1World.transform.translation.y = sin(time);
        AV1World.transform.translation.z = 0.0;
        // angle: [0, 0, t]
        tf2::Quaternion q1;
        q1.setRPY(0, 0, time);
        AV1World.transform.rotation.x = q1.x();
        AV1World.transform.rotation.y = q1.y();
        AV1World.transform.rotation.z = q1.z();
        AV1World.transform.rotation.w = q1.w();

        // --- AV2 ---
        AV2World.header.stamp = ros::Time::now();
        AV2World.header.frame_id = "world";
        AV2World.child_frame_id = "av2";
        // path: [sin(t), 0, cos(2t)]
        AV2World.transform.translation.x = sin(time);
        AV2World.transform.translation.y = 0.0;
        AV2World.transform.translation.z = cos(2 * time);

        // Publish the transforms
        tf_broadcaster.sendTransform(AV1World);
        tf_broadcaster.sendTransform(AV2World);
    }
};

int main(int argc, char** argv) {
    ros::init(argc, argv, "frames_publisher_node");
    FramesPublisherNode node;
    ros::spin();
    return 0;
}
    \end{minted}

    \item \textit{plots\_publisher\_node.cpp}
    \begin{minted}[fontsize=\footnotesize,frame=single,linenos,breaklines]{cpp}
#include <geometry_msgs/Point.h>
#include <ros/ros.h>
#include <tf2_ros/transform_listener.h>
#include <visualization_msgs/MarkerArray.h>

#include <iostream>
#include <list>

class PlotsPublisherNode {
  ros::Time startup_time;
  ros::Timer heartbeat;
  ros::NodeHandle nh;
  ros::Publisher markers_pub;
  tf2_ros::Buffer tf_buffer{ros::Duration(10.0), true};
  tf2_ros::TransformListener tf_listener{tf_buffer};
  int num_trails;

  class TrajTrail {
    PlotsPublisherNode* parent;
    static int id;
    std::list<geometry_msgs::Point> poses;
    std::string ref_frame, dest_frame;
    size_t buffer_size;

    std::string ns;
    float r, g, b, a;

    visualization_msgs::Marker marker_out;

    void update() {
      // NOTE: you need to populate this transform
      geometry_msgs::TransformStamped transform;
      try {
        transform = parent->tf_buffer.lookupTransform(
          ref_frame,
          dest_frame,
          ros::Time(0),
          ros::Duration(0.1)
        );

        while (poses.size() >= buffer_size) {
          poses.pop_front();
        }

        geometry_msgs::Point tmp;
        tmp.x = transform.transform.translation.x;
        tmp.y = transform.transform.translation.y;
        tmp.z = transform.transform.translation.z;
        poses.push_back(tmp);
      } catch (const tf2::TransformException& ex) {
        ROS_ERROR_STREAM("transform lookup failed: " << ex.what());
      }
    }

   public:
    TrajTrail() : parent(nullptr){};

    TrajTrail(PlotsPublisherNode* parent_,
              const std::string& ref_frame_,
              const std::string& dest_frame_,
              int buffer_size_ = 160)
        : parent(parent_),
          ref_frame(ref_frame_),
          dest_frame(dest_frame_),
          buffer_size(buffer_size_) {
      if (buffer_size <= 0) {
        ROS_ERROR_STREAM("invalid buffer size! defaulting to 10");
        buffer_size = 10;
      }

      marker_out.header.frame_id = ref_frame;
      marker_out.ns = "trails";
      marker_out.id = parent->num_trails++;
      marker_out.type = visualization_msgs::Marker::LINE_STRIP;
      marker_out.action = visualization_msgs::Marker::ADD;
      marker_out.color.a = 0.8;
      marker_out.scale.x = 0.02;
      marker_out.lifetime = ros::Duration(1.0);
    }

    void setColor(float r_, float g_, float b_) {
      marker_out.color.r = r_;
      marker_out.color.g = g_;
      marker_out.color.b = b_;
    }

    void setNamespace(const std::string& ns_) { marker_out.ns = ns_; }

    void setDashed() { marker_out.type = visualization_msgs::Marker::LINE_LIST; }

    visualization_msgs::Marker getMarker() {
      update();
      marker_out.header.stamp = ros::Time::now();
      marker_out.points.clear();
      for (auto& p : poses) marker_out.points.push_back(p);

      if (marker_out.type == visualization_msgs::Marker::LINE_LIST && poses.size() % 2)
        marker_out.points.resize(poses.size() - 1);

      return marker_out;
    }
  };

  TrajTrail av1trail;
  TrajTrail av2trail;
  TrajTrail av2trail_rel;

 public:
  PlotsPublisherNode() : tf_listener(tf_buffer), num_trails(0) {
    startup_time = ros::Time::now();
    markers_pub = nh.advertise<visualization_msgs::MarkerArray>("visuals", 0);
    heartbeat =
        nh.createTimer(ros::Duration(0.02), &PlotsPublisherNode::onPublish, this);
    heartbeat.start();
    av1trail = TrajTrail(this, "world", "av1", 300);
    av1trail.setColor(0.25, 0.52, 1.0);
    av1trail.setNamespace("Trail av1-world");
    av2trail = TrajTrail(this, "world", "av2", 300);
    av2trail.setColor(0.8, 0.4, 0.26);
    av2trail.setNamespace("Trail av2-world");
    av2trail_rel = TrajTrail(this, "av1", "av2", 160);
    av2trail_rel.setDashed();
    av2trail_rel.setColor(0.8, 0.4, 0.26);
    av2trail_rel.setNamespace("Trail av2-av1");

    ROS_INFO_STREAM("Waiting for av1 and av2 transforms to be broadcast...");
    while (ros::ok()) {
      const bool av1_present = tf_buffer.canTransform("av1", "world", ros::Time(0));
      const bool av2_present = tf_buffer.canTransform("av2", "world", ros::Time(0));
      if (av1_present && av2_present) {
        ROS_INFO_STREAM("Necessary frames are present, starting!");
        break;
      }
    }
  }

  void onPublish(const ros::TimerEvent&) {
    visualization_msgs::MarkerArray visuals;
    visuals.markers.resize(2);
    visualization_msgs::Marker& av1(visuals.markers[0]);
    visualization_msgs::Marker& av2(visuals.markers[1]);
    av1.header.frame_id = "av1";
    av1.ns = "AVs";
    av1.id = 0;
    av1.header.stamp = ros::Time();
    av1.type = visualization_msgs::Marker::MESH_RESOURCE;
    av1.mesh_resource = "package://two_drones_pkg/mesh/quadrotor.dae";
    av1.action = visualization_msgs::Marker::ADD;
    av1.pose.orientation.w = 1.0;
    av1.scale.x = av1.scale.y = av1.scale.z = av1.color.a = 1.0;
    av1.color.r = 0.25;
    av1.color.g = 0.52;
    av1.color.b = 1.0;
    av1.lifetime = ros::Duration(1.0);
    av2 = av1;
    av2.header.frame_id = "av2";
    av2.ns = "AVs";
    av2.id = 1;
    av2.color.r = 0.8;
    av2.color.g = 0.4;
    av2.color.b = 0.26;

    // Trails
    visuals.markers.push_back(av1trail.getMarker());
    visuals.markers.push_back(av2trail.getMarker());
    visuals.markers.push_back(av2trail_rel.getMarker());
    markers_pub.publish(visuals);
  }
};

int main(int argc, char** argv) {
  ros::init(argc, argv, "plots_publisher_node");
  PlotsPublisherNode node;
  ros::spin();
  return 0;
}
    \end{minted}
\end{itemize}



\end{document}